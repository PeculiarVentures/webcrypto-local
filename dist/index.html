<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>

<body>
    <script src="http://cdn.rawgit.com/dcodeIO/protobuf.js/6.6.0/dist/protobuf.js"></script>
    <script src="https://cdn.rawgit.com/jakearchibald/idb/97e4e878/lib/idb.js"></script>
    <script src="https://peculiarventures.github.io/pv-webcrypto-tests/src/webcrypto-liner.min.js"></script>
    <script src="https://peculiarventures.github.io/pv-webcrypto-tests/src/asmcrypto.js"></script>
    <script src="https://peculiarventures.github.io/pv-webcrypto-tests/src/elliptic.js"></script>
    <script src="./webcrypto-socket.js"></script>
    <script>
        var ws = new WebcryptoSocket.SocketCrypto();
        ws.connect("127.0.0.1:8080")
            .on("error", (e) => {
                console.error(e.error);
            })
            .on("listening", (e) => {
                console.info(e.address);
                Test8();
            })
            .on("close", (e) => {
                console.info("close");
            });

        function Test() {
            // var alg = { name: "RSASSA-PKCS1-v1_5", hash: "SHA-256", publicExponent: new Uint8Array([1, 0, 1]), modulusLength: 1024 }
            // var alg = { name: "RSA-PSS", hash: "SHA-256", publicExponent: new Uint8Array([1, 0, 1]), modulusLength: 1024, saltLength: 32 }
            var alg = { name: "ECDSA", hash: "SHA-256", namedCurve: "P-256" }
            ws.subtle.generateKey(
                alg,
                true,
                ["sign", "verify"]
            )
                .then((keys) => {
                    window.keys = keys;
                    console.log(keys.publicKey.algorithm.name);
                    return ws.subtle.exportKey("jwk", keys.privateKey);
                })
                .then((jwk) => {
                    console.log(jwk);
                    return ws.subtle.sign(alg, keys.privateKey, new Uint8Array([1, 2, 3, 4, 5]));
                })
                .then((signature) => {
                    console.log("Signature:", new Uint8Array(signature));
                    return ws.subtle.verify(alg, keys.publicKey, signature, new Uint8Array([1, 2, 3, 4, 5]));
                })
                .then((trusted) => {
                    console.log("Verification:", trusted);
                })
                .catch(e => {
                    console.error(e);
                })
        }

        function Test2() {
            const alg = { name: "AES-CBC", length: 256, iv: new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6]) };
            ws.subtle.generateKey(alg, false, ["encrypt", "decrypt"])
                .then((key) => {
                    window.key = key;
                    console.info("Algorithm", key.algorithm.name);
                    return ws.subtle.encrypt(alg, key, new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]));
                })
                .then((data) => {
                    return ws.subtle.decrypt(alg, key, data);
                })
                .then((data) => {
                    console.log(new Uint8Array(data));
                })
                .catch((e) => {
                    console.error(e);
                })
        }

        function Test3() {
            console.log("DERIVE BITS")
            const alg = { name: "ECDH", namedCurve: "P-256" };
            ws.subtle.generateKey(alg, false, ["deriveBits"])
                .then((keys) => {
                    window.keys = keys;
                    console.info("Algorithm", keys.privateKey.algorithm.name);
                    return ws.subtle.deriveBits({ name: "ECDH", public: keys.publicKey }, keys.privateKey, 128);
                })
                .then((data) => {
                    console.log(new Uint8Array(data));
                })
                .catch((e) => {
                    console.error(e);
                })
        }

        function Test4() {
            console.log("DERIVE KEY")
            const alg = { name: "ECDH", namedCurve: "P-256" };
            ws.subtle.generateKey(alg, false, ["deriveKey"])
                .then((keys) => {
                    window.keys = keys;
                    console.info("Algorithm", keys.privateKey.algorithm.name);
                    return ws.subtle.deriveKey({ name: "ECDH", public: keys.publicKey }, keys.privateKey, { name: "AES-CBC", length: 256 }, false, ["encrypt"]);
                })
                .then((key) => {
                    console.log(key);
                })
                .catch((e) => {
                    console.error(e);
                })
        }

        function Test5() {
            var rsaKeys, aesKey;
            var aesAlg = { name: "AES-CBC", length: 256 };

            ws.subtle.generateKey({ name: "RSA-OAEP", hash: "SHA-256", modulusLength: 1024, publicExponent: new Uint8Array([1, 0, 1]) }, false, ["encrypt", "decrypt", "wrapKey", "unwrapKey"])
                .then((keys) => {
                    rsaKeys = keys;
                    return ws.subtle.generateKey(aesAlg, true, ["encrypt"]);
                })
                .then((key) => {
                    aesKey = key;
                    return ws.subtle.wrapKey("raw", aesKey, rsaKeys.publicKey, { name: "RSA-OAEP" });
                })
                .then((data) => {
                    console.log(new Uint8Array(data));

                    return ws.subtle.unwrapKey("raw", data, rsaKeys.privateKey, { name: "RSA-OAEP" }, aesAlg, false, ["encrypt"]);
                })
                .then((key) => {
                    console.log(key);
                })
                .catch((e) => {
                    console.error(e);
                })

        }

        function Test6() {
            console.log("EXPORT/IMPORT")
            const alg = { name: "ECDH", namedCurve: "P-256" };
            ws.subtle.generateKey(alg, true, ["deriveBits"])
                .then((keys) => {
                    window.keys = keys;
                    console.info("Algorithm", keys.privateKey.algorithm.name);
                    return ws.subtle.exportKey("pkcs8", keys.privateKey);
                })
                .then((data) => {
                    return ws.subtle.importKey("pkcs8", data, alg, false, ["deriveBits"]);
                })
                .then((key) => {
                    console.log(key);
                })
                .catch((e) => {
                    console.error(e);
                })
        }

        function Test7() {
            var alg = { name: "RSASSA-PKCS1-v1_5", hash: "SHA-256", publicExponent: new Uint8Array([1, 0, 1]), modulusLength: 1024 }
            // var alg = { name: "RSA-PSS", hash: "SHA-256", publicExponent: new Uint8Array([1, 0, 1]), modulusLength: 1024, saltLength: 32 }
            // var alg = { name: "ECDSA", hash: "SHA-256", namedCurve: "P-256" }
            var keys;
            var data = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]);
            ws.subtle.generateKey(
                alg,
                false,
                ["sign", "verify"]
            )
                .then((k) => {
                    keys = k;
                    // Save keys to remote storage
                    return ws.keyStorage.setItem("rsa-pkey", k.privateKey)
                        .then(() => {
                            return ws.keyStorage.setItem("rsa-pubkey", k.publicKey);
                        })
                })
                .then(() => {
                    // Get list of names of remote keys
                    return ws.keyStorage.keys()
                        .then((keys) => {
                            console.log("KeyStorage keys:", keys);
                        });
                })
                .then(() => {
                    return ws.keyStorage.getItem("rsa-pkey")
                        .then((key) => {
                            return ws.subtle.sign(alg, key, data);
                        });
                })
                .then((signature) => {
                    console.log("Signature:", new Uint8Array(signature));
                })
                .catch(e => {
                    console.error(e);
                })
        }

        function HexToArray(hexString) {
            var res = new Uint8Array(hexString.length / 2);
            for (var i = 0; i < hexString.length; i = i + 2) {
                var c = hexString.slice(i, i + 2);
                res[i / 2] = parseInt(c, 16);
            }
            return res.buffer;
        }

        function Test8() {
            const cert = HexToArray("308203A830820290A003020102020900FEDCE3010FC948FF300D06092A864886F70D01010505003034310B300906035504061302465231123010060355040A0C094468696D796F7469733111300F06035504030C084365727469676E61301E170D3037303632393135313330355A170D3237303632393135313330355A3034310B300906035504061302465231123010060355040A0C094468696D796F7469733111300F06035504030C084365727469676E6130820122300D06092A864886F70D01010105000382010F003082010A0282010100C868F1C9D6D6B3347526821EECB4BEEA5CE126ED114761E1A27C16784021E4609E5AC863E1C4B19692FF186D6923E12B62F7DDE2362F9107B948CF0EEC79B62CE7344B700825A33C871B19F281070F389019D311FE86B4F2D15E1E1E96CD806CCE3B3193B6F2A0D0A995127DA59ACC6BC884568A33A9E722155316F0CC17EC575FE9A20A9809DEE35F9C6FDC48E3850B155AA6BA9FAC48E309B2F7F432DE5E34BE1C785D425BCE0E228F4D90D77D3218B30B2C6ABF8E3F141189200E7714B53D940887F7251ED5B26000EC6F2A28256E2A3E186317253F3E442016F626C825AE054AB4E7632CF38C16537E5CFB111A08C146629F22B8F1C28D69DCFA3A5806DF0203010001A381BC3081B9300F0603551D130101FF040530030101FF301D0603551D0E041604141AEDFE413990B42459BE01F252D545F65A39DC1130640603551D23045D305B80141AEDFE413990B42459BE01F252D545F65A39DC11A138A4363034310B300906035504061302465231123010060355040A0C094468696D796F7469733111300F06035504030C084365727469676E61820900FEDCE3010FC948FF300E0603551D0F0101FF040403020106301106096086480186F8420101040403020007300D06092A864886F70D0101050500038201010085031E9271F642AFE1A3619EEBF3C00FF2A5D4DA95E6D6BE68363D7E6E1F4C8AEFD10F216D5EA55263CE12F8EF2ADA6FEB37FE1302C7CB3B3E226BDA612E7FD4723DDD30E11E4C40198C0FD79CD183307B9859DC7DC6B90C294CA133A2EB673A6584D396E2ED7645708FB52BDEF923D6496E3C14B5C69F351E50D0C18F6A70440262CBAE1D6841A7AA57E853AA07D206F6D514060B9103752C6C72B561959A0D8BB90DE7F5DF54CDDEE6D8D609089763E5C12EB0B74426C026C0AF55309E3BD5362A1904F45C1EFFCF2CB7FFD0FD874011D51123BB48C021A9A4282DFD15F8B04E2BF4305B21FC119134BE41EF7B9D9775FF9795C096582FEABB46D7BBE4D92E");

            var alg = {name: "RSASSA-PKCS1-v1_5", hash: "SHA-256"}
            ws.certStorage.importCert("x509", cert, alg, ["verify"])
                .then((x509) => {
                    return ws.certStorage.setItem("my-cert", x509);
                })
                .then(() => {
                    return ws.certStorage.getItem("my-cert");
                })
                .then((x509) => {
                    console.log(x509);
                })
                .catch((e) => {
                    console.log(e);
                });
        }
    </script>
</body>

</html>